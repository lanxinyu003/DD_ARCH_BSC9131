// common.l3k
// *** Copyright Freescale Semiconductor, Inc, 2010 *** 

// This file provides definition common to all cores.

 arch(psc9131);
 number_of_cores(1);
 
 entry("___crt0_start");

 _NUMBER_OF_CORES = 1;
 
// The value to set the Core Status Register (SR) after reset:
//  - Exception mode
//  - Interrupt level 31
//  - Saturation mode enabled
//  - Rounding mode: nearest even
 _SR_Setting = 0x3e4000c;

/** M2/L2 size 
*	If user wants to change the configuration he must uncomment the text below
*	Default value speciffied in Machine Model is _M2_Setting = 0x0f that coresponds to M2_size = 256KB;
*/

// BSC9131 memory layout

// ---------------------------------
// _M2_Setting configuration for M2
// ------------------
// M2 size  Rule-set
// ------------------
//   0KB     0x00 - all used as L2Cache
//  64KB     0x01
// 128KB     0x03
// 192KB     0x07
// 256KB     0x0f
// 320KB     0x1f
// 384KB     0x3f
// 448KB     0x7f
// 512KB     0xff

 _M2_Setting= 0x0f;

ASSERT ((_M2_Setting == 0x01) || 
		 (_M2_Setting == 0x03) || 
		 (_M2_Setting == 0x07) || 
		 (_M2_Setting == 0x0f) || 
		 (_M2_Setting == 0x1f) || 
		 (_M2_Setting == 0x3f) || 
		 (_M2_Setting == 0x7f) || 
		 (_M2_Setting == 0xff) ||
		 (_M2_Setting == 0x00), "_M2_Setting Assert - not a possible value");
		 


assert( ((_M2_Setting == 0x00 && _ENABLE_VTB != 1) || (_M2_Setting != 0x00)), "VTB should be reserved in M3 or DDR ");

/**
* Machine Model defined Symbols - Memory sizes
*/

 _M2_start	=	0xB0000000  ;
 _M2_size	=	(_M2_Setting == 0x01) ? 0x10000 :
				(_M2_Setting == 0x03) ? 0x20000 :
				(_M2_Setting == 0x07) ? 0x30000 :
				(_M2_Setting == 0x0f) ? 0x40000 :
				(_M2_Setting == 0x1f) ? 0x50000 :
				(_M2_Setting == 0x3f) ? 0x60000 :
				(_M2_Setting == 0x7f) ? 0x70000 :
				(_M2_Setting == 0xff) ? 0x80000 :
				0x0;	// M2 size.
 _M2_end =		_M2_start + _M2_size - 1 ;

 _DDR_start	=	0x00000000;
 _DDR_size	=	0x20000000;		//DDR size (512M)
 _DDR_end	=	_DDR_start + _DDR_size -1;
 
 _Flash_start	= 0x80000000;
 _Flash_size	= 0x10000000;
 _Flash_end		= _Flash_start + _Flash_size -1;
 
 /* Define the physical memories*/
 
 physical_memory private (*) {
	M2: org = _M2_start, len = _M2_size;
	DDR: org = _DDR_start, len = _DDR_size;
	
	FLASH: org = _Flash_start, len = _Flash_size;
 }

// Application memory layout
// ===========================
// There are two distinct virtual spaces:
// - One for program
// - One for data (due to MMU implementation).
// These two spaces may overlap and have the range 0..4G.

// Shared IPC data is mapped in M3
// Private data is mapped in M2,M3 and DDR
// Shared data and code is mapped in M3, DDR
// Private code stays in M2


// Define size for Boot/MMU tables 
 _MMU_TABLES_size= 0x100;

// Define the size of stack.
 _StackSize = 0x7f00;
 
// The size of boot descriptor must be power of two.
 _DATA_BOOT_size = _MMU_TABLES_size + _StackSize ;
 
// Define the size of Heap to 4k 
 _HeapSize= 0x1000;

// Define sizes for private text and data
 _PRIVATE_M2_TEXT_size = 0x2000;
 _PRIVATE_M2_DATA_size =  _M2_size - _PRIVATE_M2_TEXT_size - _DATA_BOOT_size;


// Define the size for private data to stay in DDR
 _PRIVATE_DDR_DATA_size = 0x80000;

// Defines for virtual memory map placement
 _VIRTUAL_MEM_DATA_start= 0x70000000;
 _VIRTUAL_DATA_BOOT_start =	0x20000000;
 _VIRTUAL_M2_text_start  = 0x38000000;
 
// Stack and heap area boundaries in virtual private memory data space, for runtime support
 _StackStart=  originof("stack");
 _TopOfStack =(endof("stack")-7)&0xFFFFFFF8;
 __BottomOfHeap = originof("heap");
 __TopOfHeap =  (endof("heap")-7)&0xFFFFFFF8;
  


// Application physical layout
// ===========================

// Define the physical memory for M2 private data
 _M2_PRIVATE_start = _M2_start ;
 
// Define the physical memory for DDR private data
 _DDR_PRIVATE_start= _DDR_start;
								

// The descriptor for att_mmu tables and stack is placed at the end of shared M3
 _DATA_BOOT_start = _M2_end - _DATA_BOOT_size + 1;
 _DATA_BOOT_end = _DATA_BOOT_start + _DATA_BOOT_size - 1;


// Reserve VTB are in physical memory
// Set VTB start address and size for M2, M3 and DDR
 _M2_VTB_size= 0x1000;	//4K for each core
 _DDR_VTB_size= 0x1000;	//4K for each core
 
 
 _VTB_size = (_ENABLE_VTB == 1)? _M2_VTB_size: 
						 (_ENABLE_VTB == 2)? _DDR_VTB_size:
							0x0;
							
 _VTB_start= (_ENABLE_VTB == 1)?( _M2_end - _DATA_BOOT_size -_M2_VTB_size + 1): 
						 (_ENABLE_VTB == 2)? (_DDR_end  - _DDR_VTB_size + 1): 
							0x0;


 _VTB_end =  _VTB_start + _VTB_size;

physical_memory private (*){
			reserve: org = _VTB_start, len = _VTB_size;	
}


// Renaming program sections that are part of the boot code from 
// runtime library and OS library.
RENAME "*startup*.eln", ".text", ".text_boot"
RENAME "*rtlib_*.elb(target_asm_start.eln)", ".text", ".text_boot"
RENAME "*rtlib_*.elb(target_c_start.eln)", ".text", ".text_boot"
RENAME "*rtlib_*.elb(classic_syscall.eln)", ".text", ".text_boot"
RENAME "*hostio_*.elb(hsst_syscall.eln)", ".text", ".text_boot"

//For C++ projects, the value will be overwritten in the command line.
ENABLE_EXCEPTION = 0x0;

_cpp_staticinit_start= originof(".staticinit");
_cpp_staticinit_end= endof(".staticinit");

__exception_table_start__ = (ENABLE_EXCEPTION) ?originof(".exception_index"):0;
__exception_table_end__ = (ENABLE_EXCEPTION) ?endof(".exception_index"):0; 

